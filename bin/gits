#!/usr/bin/perl

use Cwd;
my $wd = getcwd;
my @args = @ARGV;
my $command = shift @args;
my ($k, $v, $p);
my @repos;
while (my $str = pop @args) {
    if (-d $str && -d "$str/.git") {
        $str =~ s/\/$//g;
        unshift @repos, $str;
    }
    elsif ($str eq '-k') {
        $k = 1;
    }
    elsif ($str eq '-v') {
        $v = 1;
    }
    elsif ($str eq '-p') {
        $p = 1;

        # -p implies -k because it doesn't make sense to try to stop
        # the child processes mid-way through the repo loop
        $k = 1;
    }
    else {
        push @args, $str;
        last;
    }
}
unless(@repos){
    foreach my $str ( glob('*') ) {
        if (-d $str && -d "$str/.git") {
            push @repos, $str;
        }
    }
}
my $parent_pid = $$;
my $children = 0;
foreach my $repo (@repos) {
    my $child_pid = $p ? fork : 0;
    if ($child_pid) {
        $children++;
    }
    elsif (! defined $child_pid) {
        die "failed to fork";
    }
    else {
        chdir "$wd/$repo" or die "failed to chdir $wd/$repo";
        my @this_args = @args;
        map {s/_REPO_/$repo/} @this_args;
        open(EXEC, '-|', 'git', split(/ /, $command), @this_args);
        my $o = '';
        while (<EXEC>) {
            chomp($_);
            my $trimmed = substr($_, 0, 250);
            $trimmed .= '...'
                if !$v && length($trimmed) < length($_);
            $o .= "$trimmed\n";
        }
        close(EXEC);
        if ($? && $k) {
            print STDERR "error: $?\n" if $v;
            $parent_pid == $$ ? next : exit 0;
        }
        else {
            print STDERR "=================== $repo ===================\n$o\n";
            die $? if $?;
        }
        exit 0
            unless $parent_pid == $$;
    }
}

wait for 1 .. $children;
